// Archivo: server.js
// Este backend utiliza Node.js, Express y Mongoose para gestionar una lista de juegos.

const express = require('express');
const mongoose = require('mongoose');
const dotenv = require('dotenv');
const cors = require('cors'); 

// Cargar variables de entorno (necesita el MONGODB_URI)
dotenv.config();

// Inicializar Express
const app = express();
const PORT = process.env.PORT || 3001;
const MONGODB_URI = process.env.MONGODB_URI;

// Middleware
app.use(cors()); // Permite peticiones desde el frontend (puerto 3000 o el que uses)
app.use(express.json()); // Permite a Express leer el cuerpo de peticiones JSON

// -------------------------------------------------------------
// DEFINICI√ìN DEL ESQUEMA Y MODELO DE JUEGO
// -------------------------------------------------------------
const GameSchema = new mongoose.Schema({
    title: { 
        type: String, 
        required: [true, 'El t√≠tulo del juego es obligatorio.'],
        trim: true 
    },
    genre: { 
        type: String, 
        required: [true, 'El g√©nero es obligatorio.'],
        trim: true 
    },
    platform: { 
        type: String, 
        required: [true, 'La plataforma es obligatoria.'],
        trim: true 
    },
    releaseYear: { 
        type: Number, 
        required: [true, 'El a√±o de lanzamiento es obligatorio.'],
        min: 1950,
        max: new Date().getFullYear() + 5 
    },
    rating: { 
        type: Number, 
        default: 0, 
        min: 0, 
        max: 5 
    },
    cover: { 
        type: String, 
        default: 'https://placehold.co/150x200/cccccc/000000?text=JUEGO'
    },
}, { 
    timestamps: true // Para tener 'createdAt' y 'updatedAt'
});

// Modelo de Mongoose
const Game = mongoose.model('Game', GameSchema);

// -------------------------------------------------------------
// FUNCIONES DE UTILIDAD PARA MANEJO DE ERRORES
// -------------------------------------------------------------

// Funci√≥n para manejar errores de validaci√≥n de Mongoose
const handleValidationErrors = (res, error) => {
    if (error.name === 'ValidationError') {
        const messages = Object.values(error.errors).map(val => val.message);
        return res.status(400).json({ 
            message: 'Datos de juego inv√°lidos.', 
            errors: messages 
        });
    }
    // Para otros errores (ej. error de conexi√≥n a DB)
    console.error("Error inesperado:", error.message);
    res.status(500).json({ message: 'Error interno del servidor.' });
};


// -------------------------------------------------------------
// RUTAS DE LA API (CRUD COMPLETO)
// -------------------------------------------------------------

// 1. READ (GET) - Obtener todos los juegos
app.get('/api/games', async (req, res) => {
    try {
        const games = await Game.find().sort({ title: 1 });
        res.status(200).json(games);
    } catch (error) {
        handleValidationErrors(res, error);
    }
});

// 2. CREATE (POST) - Crear un nuevo juego (Commit #5)
app.post('/api/games', async (req, res) => {
    try {
        const newGame = new Game(req.body);
        const savedGame = await newGame.save();
        res.status(201).json(savedGame); // 201 Created
    } catch (error) {
        handleValidationErrors(res, error);
    }
});

// 3. UPDATE (PUT) - Actualizar un juego existente (Commit #6)
app.put('/api/games/:id', async (req, res) => {
    try {
        const { id } = req.params;
        
        // El tercer argumento { new: true } retorna el documento actualizado
        // El argumento { runValidators: true } ejecuta las validaciones de Mongoose en el PUT
        const updatedGame = await Game.findByIdAndUpdate(
            id, 
            req.body, 
            { new: true, runValidators: true }
        );

        if (!updatedGame) {
            return res.status(404).json({ message: 'Juego no encontrado.' });
        }
        
        res.status(200).json(updatedGame);

    } catch (error) {
        // Mongoose lanza un error si el ID no es v√°lido (CastError)
        if (error.name === 'CastError' && error.kind === 'ObjectId') {
            return res.status(400).json({ message: 'ID de juego inv√°lido.' });
        }
        handleValidationErrors(res, error);
    }
});

// 4. DELETE (DELETE) - Eliminar un juego (Commit #7)
app.delete('/api/games/:id', async (req, res) => {
    try {
        const { id } = req.params;
        
        const deletedGame = await Game.findByIdAndDelete(id);

        if (!deletedGame) {
            return res.status(404).json({ message: 'Juego no encontrado.' });
        }

        // 204 No Content es el est√°ndar para una eliminaci√≥n exitosa
        res.status(204).send(); 

    } catch (error) {
         if (error.name === 'CastError' && error.kind === 'ObjectId') {
            return res.status(400).json({ message: 'ID de juego inv√°lido.' });
        }
        console.error("Error al eliminar el juego:", error.message);
        res.status(500).json({ message: 'Error interno del servidor al eliminar.' });
    }
});

// -------------------------------------------------------------
// FUNCI√ìN DE CONEXI√ìN A MONGODB E INICIO DEL SERVIDOR
// -------------------------------------------------------------
const connectDB = async () => {
    if (!MONGODB_URI) {
        console.error("‚ùå ERROR CR√çTICO: La variable MONGODB_URI no est√° definida en el archivo .env.");
        return;
    }
    try {
        await mongoose.connect(MONGODB_URI);
        console.log('‚úÖ MongoDB Atlas: ¬°Conexi√≥n exitosa y modelo de datos definido!');
        
        app.listen(PORT, () => {
            console.log(`üöÄ Servidor ejecut√°ndose en http://localhost:${PORT}`);
            console.log(`Rutas API disponibles:`);
            console.log(`- GET/POST: http://localhost:${PORT}/api/games`);
            console.log(`- PUT/DELETE: http://localhost:${PORT}/api/games/:id`);
        });

    } catch (error) {
        console.error('‚ùå MongoDB Atlas: ERROR de conexi√≥n.', error.message);
        process.exit(1); // Detiene el proceso si no se puede conectar
    }
};

connectDB();